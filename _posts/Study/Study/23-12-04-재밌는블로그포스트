위임이란? 
```cs
## client.cs
var t = new MyTask();
t.method();
```
첫째줄에서 다른 객체를 생성했다.

둘째줄에서 생성한 객체의 메소드를 호출했다 "(messaginf)"

위와 같이 메소드 호출을 통해 다른 객체를 사용하는 것을 "위임(Delegation)"이라고 한다

위처럼 client가 MyTask를 호출했으니, Client가 MyTask에 "의존"(Dependency)한다 라고 부른다.

위 코드에서 "의존"은 두번 발생했다.

개발에서 의존은 필연적으로 발생한다. 객체를 분리하고 객체끼리 소통하기 위해 다른 객체를 참조하고 접근해야 하는 일은 피할 수 없다.

더 많은 의존은 한 객체의 수정이 그 객체에 의존하는 더 많은 객체의 수정을 불러옴을 의미한다. 이를 막으려먼 어떻게 해야 할까? 객체를 사용하는 대상이 수정될 가능성을 낮춰야 한다. 어떻게?

이를 해결하기 위해 우리는 객체지향 설계의 5원칙을 적극적으로 활용해야 한다.

* 단일 책임 원칙

객체는 하나의 책임을 가져야 한다

는

객체는 하나의 책임(변경해야 할 이유)을 가져야 한다

라는 뜻이다.

 * 책임의 종류

생성 책임 : 구체 객체를 생성해야 한다. 생성자와 구체 객체간의 추상화(서로에 대해 추상적으로 인식해야)를 지켜야 한다.

구현  책임 : 객체(생성 객체가 아닌 구체 객체)는 요구사항에 맞게 동작을 수행할 수 있어야 한다. 이는 interface나 super class를 상속받음으로써 구현이 강제되기도 하고, 자체적으로 공개메소드로 구현되기도 한다.

계약 책임 ★ : 계약 책임은 interface에 대한 책임이다. 구체 객체는 행위를 구현하는대에 있어 자율성을 갖는다. 하지만 interface(즉, 계약)에 있는 내용은 반드시 지켜져야만 한다. + 이런 개념으로 interface를 이해하며느 리스코프 치환 원칙이 자연스럽게 지켜진다고 한다. ['리스코프 치환 원칙 포스트 1'  ](https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle)['리스코프 치환 원칙 포스트 2'  ](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99)['리스코프 치환 원칙 포스트 3'](https://velog.io/@harinnnnn/OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EB%8C%80-%EC%9B%90%EC%B9%99SOLID-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-LSP)

--------------


