---
title: 객체지향에 대한 고찰
author: unwoo52
date: 2023-12-05 00:00:00 +09:00
categories: [OOP]
tags: [OOP]
---


[객체지향에 관한 고찰 포스트 시리즈](https://effectiveprogramming.tistory.com/category/3.%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%28OOP%29%20%EA%B0%9C%EB%85%90)
> 위 링크는 이 사람이 객체지향에 대해 생각한 것을 정리한 포스트 시리즈 링크. 3번정도 방문했는데, 방문할 때 마다 일일 방문자가 50~150명은 되는 블로그. 이 사람은 객체지향을 심도 있게 고민하고, 더 나은 객체지향을 구현하기 위해 객체지향의 본질에 대해 파헤치고, 적절한 비유를 가미해서 이 본질이 무엇인지 설명을 해주며, 자신이 생각하는 객체지향이 어떻게 구현될 수 있는지 어떤 모습을 바라보는지 설명하고 있다.

<br>
<br>

-----------

<br>

##### 개발자들은 자신이 이해하고 있는 객체지향을 항상 변화하고 발전해야만 한다
세상 그 어떤 개발자도 객체지향을 처음 접했을 때 이해한 느낌을 평생 바꾸지 않고 개발할 수 있을 것이라고 생각하지 않는다.

객체지향을 배우기 위해서는 스스로가 계속해서 객체지향에 대해 끊임없이 고찰하고 생각하고 발전시키기 위해 노력해야 한다고 생각한다.
<br>
##### 객체지향은 명확하게 이해할 수 있는 하나의 견고한 원칙이 아니다. 개발은 항상 다르기 때문이다.
그 누구도 객체지향을 처음 배웠을 때 한번에 이해하고 흡수할 수 없다. 왜냐면 객체지향 자체가 추상적인 덕분에 각기 다른 다양한 개발에 모두 적용될 수 있는 다형성을 갖기 때문이다. 1만개의 개발이 있으면 각기 1만개의 개발의 모습, 추구하는 방향, 개발하는 사람의 성향이 모두 각기 다르다. 그런데 이 각기 다른 1만개의 개발에 적용될 수 있는 하나의 원칙이 어떻게 존재할 수 있는가? 

개발의 목표, 개발하면서 우선시 해야 할 가치들의 순위, 개발하는 모습은 계속해서 꾸준히 발전하고 바뀐다. 이러한 것들이 바뀌면 당연히 우리가 갖고 있는 객체지향에 대한 인식, 생각 또한 바뀌어야 하는 것이 당연하다.
<br>

##### 개발의 모습들이 아무리 서로 달라도, 공통적으로 추구하는 가치는 존재한다
객체지향은 모든 개발에 있을 수 있는 공통점들을 추리고, 모든 개발자들이 공감할 수 있는 가치(방대하고 복잡하게 구현된 기능들을 적은 비용으로 추적하고 개선하고 오류를 수정할 수 있는)를 추구하는 원칙을 구현한 것 이라고 생각한다.

 그렇기 때문에 객체지향은 추상적이고 모호하며 본질이 흐릿한 것 이다. 이 추상적인 특징 때문에 우리 자신들이 이해하고 있는 객체지향들은 타자가 이해하고 있는 객체지향과 (비슷할 수 는 있어도)항상 같지 않고 차이가 있다.

 객체지향의 정의는 언제나 동적일 것 이고, 배우는 사람 마다 조금씩은 다르게 이해하며, 각기 개발들에게 있어 항상 다른 모습으로 적용될 것이다.

<br>

##### 객체지향을 추구하기 위해 남들이 객체지향을 어떻게 생각하는지 물어보고 의견을 공유하라

자신이 갖고 있는 객체지향의 이해를 발전시키기 위해 우리는 다른 사람이 갖고 있는 객체지향의 이해를 들어보고 공유하고 서로 이야기해보며 끊임없이 소통하고 발전시켜야 한다. 나와 다르게 생각하는 객체지향을 남에게서 듣거나 들려주고, 각기 자신이 갖고 있는 객체지향에 대한 이해를 되짚어보고 고찰해보면 더 나은 객체지향적 사고를 얻을 수 있을 것 이라고 생각한다.

<br>
<br>

----------------

## [상속에 대한 올바른 이해](https://effectiveprogramming.tistory.com/entry/%EC%83%81%EC%86%8DInheritance%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4)

객체지향을 구현하기 위해 우리는 다양한 방법을 선택할 수 있다. 인터페이스를 통해 확장시킬 수 도 있고 상속을 통해 확장시킬 수 도 있다. 그렇다면 어떤 상황에서 상속을 해야 하고 어떤 상황에서 상속이 아닌 다른 방법을 선택해야 하는가?

더 깊이 들어가서, 어떤 상황일 때 상속을 해야 하는가?

다른 방법을 쓰지 않고, 상속을 통해 구현 해야만 하는 이유가 무엇인가...?

블로그에서는 오케스트라의 비유를 통해 "대상(Type)화"라는 이야기를 하고 있다. 상속을 함으로써 대상(Type)이라는 것을 추출할 수 있게 된다는 것 이다.

##### 어떤 객체로 인식할 것 인가?
Type은 "그 객체를 어떤 객체로 인식할 것이며, 어떻게 다룰 것인가?"를 알려준다. 

어떤 객체가 있어도, 이를 object Type으로 받아서 쓴다면 이 객체를 object로만 인식할 것이다. object로 다룰 것 이며 obejct가 지원하는 기능을 사용할 것 이다 라고 말하는 것 과 같다.

만약 monoBehavior Type으로 받았다면 역시 monoBehavior로 인식할 것이며, monoBehavior의 기능들을 사용하겠다 라고 말한 것 이다.

오케스트라의 비유에서 말하자면, 지휘자는 앞에 있는 사람들(객체들)을 "연주자" 라는 대상으로 추출하였다. 만약 공연이 끝난 뒤 회식을 하게 되었다면 지휘자는 사람들(객체들)을 그보다 높은 상속 단계인 "사람" 이라는 대상으로 추출해도 무관할 것 이다. 술먹는데 지휘나 악기 연주 요청을 할 필요가 없으니까! 그리고 회식이 진행되는 동안(기능을 호출하는 함수 내에서)은 "사람"으로써의 대상(type)으로 추출한 기능들만 사용할 것 이다. '연주' 나 '지휘'가 아닌, '술먹기' '대화하기' 같은 기능 말이다.

----------

## 최소 공개 원칙과 최대 노출 원칙(테스트 가능 설계)

#### 최소 공개를 해야 하는 이유

* 같은 절차로 동작시켜도 다른 결과가 나오는 이슈 : 전역 변수의 변화를 예측하기에 코드가 너무 방대하고 많은 곳에서 사용됨
* 오류를 수정할 때 다른 함수 동작에 영향을 끼침 : 위와 같은 이유
* 하나의 수정을 위해 다른 의존과 연관이 맺어진 곳의 수정도 일어남

"왜 사람들은 더 작은 컴퓨터로 나누지 않는가?" -앨런 케이-

더 작은 컴퓨터 = 객체

더 작은 컴퓨터를 이해하는것은 쉽다. 이 작은 객체의 메세지만을 이해하고, 자세한 내부를 이해하지 않는다면 방대한 프로세스를 이해하는데 최소한의 지식만이 필요하게 될 수 있다.

#### 반대로 최대한 노출하자

위와 반대되는 내용이 아니다. 위 최소 공개를 지키면서, 테스트 가능 설계를 지향하기 위해 아래 규칙을 지키며 노출하자는 내용

* 동작에 영향을 주지 않는다면 모든 정보를 제공하라(getter)
* 모든 의존 객체에 대한 의존성 주입 함수를 제공하라(setter 혹은 Initailze(의존)) : 다른 객체에 의존성이 있는 경우, 주입 함수를 만들면, 단위 테스트시에 해당 객체를 다른 객체로 대체할 수 있어 테스트가 용이해진다.


-----------


## [객체 지향 용어 정리](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC)

정보 은닉 부분에 읽을거리가 있음

*  객체가 생성된 이후, 고유 타입이 아닌 그 상위 타입으로 지칭되도록 함으로써 생성 이후에는 객체의 고유 타입을 모르도록 하는 것. 타입을 모른 상태에서 구현할 수 있다는 것은 그 고유 타입에 의존하는 코드가 없다는 말이다. 이는 그 고유 타입 객체가 삭제되거나 수정되더라도 코드는 전혀 변경되지 않는다는 것을 의미한다.
* 다형성 : 서로 다른 객체들의 고유 타입을 은닉하고, 상위 타입을 통해 다룬다. 서로 다른 객체들에게 공통된 상위클래스의 메소드를 호출함으로써 동일한 액션(함수호출)을 통해 동작시킬 수 있다.
* 객체의 타입을 하위 타입으로 캐스팅을 금기시 함으로써  온전한 정보 은닉을 달성해야.
* 정보 은닉을 통해 고유 타입에 의존하지 않도록 함은 교체 및 확장을 용이하게 한다.
* 정보 은닉을 통해 기능의 수정 시 다른 기능에 끼치는 영향을 최소화 한다. 객체가 가진 최소한의 공개 메소드만 호출되기 때문이다.

----------------

## [TDA 원칙 ( Tell, Don't ask! )](https://effectiveprogramming.tistory.com/entry/Tell-dont-ask)

객체와 객체가 협력하는 경우, 다른 객체에게 정보를 요구하지 말고 단지 행위하라고 시키도록 해라!

그럼에도 데이터를 전달해야 하는 경우는 반드시 생긴다. 외부의 객체가 어떤 객체의 데이터를 기반으로 동작을 수행해야 하는 경우 말이다.

#### 데이터 무결성을 지키기 어렵다
객체가 협력하는 다른 객체에게서 받아온 데이터를 갖고 있으면 데이터를 핸들링 해야 한다. 핸들링을 하면 데이터는 변화한다. 즉, 데이터의 무결성을 지키기 어렵다. 특히 멀티쓰레드 환경 같은 경우에는 더욱이 심각해진다.

#### 중복 코드가 발생할 확률이 높아진다
데이터 핸들링을 하는 형태가 비슷할 확률이 높다.

#### 해결 방법
데이터를 핸들링 하는 객체를 별도로 생성한다. 그리고 결과를 다른 객체에 전달해 주는 것만을 수행한다.

##### 아무리 캡슐화를 잘 했다고 해도 getter를 통해서 데이터를 전달하거나 매개변수로 데이터를 다른 객체에 넘겨버리면 기껏 정보 은닉을 강조한 보람이 없어진다.


----
## [의존과 책임](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4-%EC%B1%85%EC%9E%84Responsibility)

### 위임이란? 
```cs
## client.cs
var t = new MyTask();
t.method();
```
첫째줄에서 다른 객체를 생성했다.

둘째줄에서 생성한 객체의 메소드를 호출했다 "(messaginf)"

위와 같이 메소드 호출을 통해 다른 객체를 사용하는 것을 "위임(Delegation)"이라고 한다

위처럼 client가 MyTask를 호출했으니, Client가 MyTask에 "의존"(Dependency)한다 라고 부른다.

위 코드에서 "의존"은 두번 발생했다.

개발에서 의존은 필연적으로 발생한다. 객체를 분리하고 객체끼리 소통하기 위해 다른 객체를 참조하고 접근해야 하는 일은 피할 수 없다.

더 많은 의존은 한 객체의 수정이 그 객체에 의존하는 더 많은 객체의 수정을 불러옴을 의미한다. 이를 막으려먼 어떻게 해야 할까? 객체를 사용하는 대상이 수정될 가능성을 낮춰야 한다. 어떻게?

이를 해결하기 위해 우리는 객체지향 설계의 5원칙을 적극적으로 활용해야 한다.

<br>

-----

## [정보 은닉](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89information-hiding%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4)

### 캡슐화 = 정보 은닉?
블로그에선 많은 사람들이 위 소제목과 같이 이해하고 있다면, 객체지향을 겉만 핥은 수준으로만 이해한 것이라고 말한다. 정보 은닉이란 정확히 무엇인가?

> "어떤 객체도 섬이 아니다" -워드 커닝헴-

아무리 객체간에 독립성을 보장하고, 연관 의존을 없애고, 객체의 내부 정보를 숨기려고 해도 우린 필연적으로 객체간의 협력을 구현해야 할 수 밖에 없다. 객체끼리 연결되고 연관되는 것은 필연적이다.

필연적으로 객체간의 관계는 발생한다. 그리고 이는 유연성을 헤친다.

그렇다면 어떻게 해야 하는가? 어떻게 객체끼리의 관계를 만드는 것이 객체지향적으로 바람직한가?

1. 자주 변경될 가능성이 있는 것에는 의존하지 않는다.
2. 외부로 노출된 메소드를 최소한으로 한다.
3. 객체의 책임을 최소한으로 줄인다.

### 정보 은닉의 종류

* 객체의 구체적인 타입 은닉(트럼펫 연주자x, 연주자o  즉, 상위 타입 캐스팅을 하라)
* 객체의 필드 및 메소드 은닉(= 캡슐화)
- 구현 은닉(인터페이스 및 추상 클래스 기반의 구현)(동작이 어떻게 작동하는지 자세한 내용을 인터페이스 등으로 은닉하라)(생성은 팩토리 패턴 등에게 맏김으로써 '어떻게 생성되는지에 대한 상세'는 은닉시켜라)

### 정보 은닉의 목적

* 구체적인 것(객체의 코드 타입 메소드 등)에 의존하는것을 막고 추상적인 것(인터페이스)을 의존하도록 한다. 객체간의 결합이 약해지고 교체와 수정은 쉬워진다.
* 동일한 타입의 다른 구현 객체들을 교체함으로써 동적 기능 변경이 가능해진다.(연주자끼리 교환되어도 추상적인 인터페이스(연주하세요)에 의존했기 때문에 동적으로 기능 변경이 가능하다)
* 연동할 구체적인 구현이 없는 상태에서도(함수 안에 코드가 작성되지 않았음에도) 연동되는 코드의 생성이 가능하다.

### 인터페이스 사용의 이점
- State 패턴 : 상태를 객체화하고, 인터페이스를 통해 상태화 된 객체를 지칭하게 함으로써 상태가 추가되기 용이하도록 한다.
- Bridge 패턴 : 연관관계가 있는 두 부류의 객체들을 두 개의 인터페이스 간의 연관관계로 바꾸고, 구체적인 객체들을 인터페이스 상속을 통해 구현 함으로써 각 부류의 객체들에 추가/삭제가 발생하더라도 다른쪽 부류에는 영향을 미치지 않도록 한다.
- Stragegy 패턴 : 기능을 담은 객체를 인자로 넘겨 줌으로써 이를 받는 객체의 기능이 변경될 수 있도록 한다. 이 역시 인터페이스를 중심으로 기능을 담은 객체를 지칭함으로써 기능의 확장이나 변경이 용이하도록 한다.
- Observer 패턴 : 관찰자 객체들을 인터페이스로 추상화하고, 관찰 대상 객체에 이벤트가 발생했을 때 인터페이스만을 활용하여 이벤트를 전달함으로써 관찰자와 관찰 대상 간의 구체적인 결합을 제거한다. 이를 통해서 관찰자에 해당하는 구체적인 객체들의 종류가 늘어나더라도 같은 관찰 대상 객체의 구현에는 영향이 없다.

--------------

### 단일 책임 원칙

"객체는 하나의 책임을 가져야 한다"

위 문장을

객체는 하나의 책임(변경해야 할 이유)을 가져야 한다

로 읽을 수 있다.

하나의 class가 여러개의 책임을 가지고 있으면, 수정해야 할 이유도 늘어나고 의존도 많을 것 이다.

그렇다고 class의 책임을 쪼갤 수 있을 만큼 무수히 쪼개는 것도 좋지 않다. class의 수가 과하게 늘어나게 되고, 코드를 읽기 힘들어질 것 이다. 

때문에 책임을 쪼개는 것은 프로그래머가 감각적으로 조절해야 한다. 어느 정도의 크기가 적당한지 얼마나 쪼개야 좋은 코드가 될 수 있는지,,, 책임을 적절한 크기로 쪼개야 한다는 주장은 이 블로그 뿐 아니라 다른 많은 사람들도 주장하는 내용이다.....

블로그에서는 책임을 아래와 같은 기준으로 나눌 것을 말하고 있다.

<br>

#### □ 책임의 종류

생성 책임 : 구체 객체를 생성해야 한다. 생성자와 구체 객체간의 추상화(서로에 대해 추상적으로 인식해야)를 지켜야 한다.

구현  책임 : 객체(생성 객체가 아닌 구체 객체)는 요구사항에 맞게 동작을 수행할 수 있어야 한다. 이는 interface나 super class를 상속받음으로써 구현이 강제되기도 하고, 자체적으로 공개메소드로 구현되기도 한다.

계약 책임 ★ : 계약 책임은 interface에 대한 책임이다. 구체 객체는 행위를 구현하는대에 있어 자율성을 갖는다. 하지만 interface(즉, 계약)에 있는 내용은 반드시 지켜져야만 한다. + 이런 개념으로 interface를 이해하며느 리스코프 치환 원칙이 자연스럽게 지켜진다고 한다. ['리스코프 치환 원칙 포스트 1'  ](https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle)['리스코프 치환 원칙 포스트 2'  ](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99)['리스코프 치환 원칙 포스트 3'](https://velog.io/@harinnnnn/OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EB%8C%80-%EC%9B%90%EC%B9%99SOLID-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-LSP)

--------------
